// ==UserScript==
// @name        iclicker script
// @namespace   iclicker script
// @match       https://student.iclicker.com/*
// @grant       none
// @version     1.0
// @author      -
// @description A userscript that allows for the following things for an iClicker Session: spoof geolocation to instructor's, auto joins class, auto answer poll q's with random answers. 
// ==/UserScript==

const JOIN_SESSION_DELAY = 2000
const SEND_ANSWER_DELAY = 2000
const MCQ_CHOICES = ["a", "b", "c", "d", "e"]

const setClassLocation = async () => {
    const course_id = sessionStorage.getItem("course_id")
    if (!this.localStorage.getItem(course_id) ) {
            const dummyGeoData = {geo: {"accuracy": 15.849,"lat": 40.2081392,"lon": -85.4085399},publicIP: null,auto: false,id: course_id}

            console.log('Getting instructor geo location data')
            angular.element(document.body).injector().invoke(["ExpressRouterService", function(i) {
                i.post("/api/courses/" + course_id + "/attendance/join", dummyGeoData).success(function() {return {}}).error(function(data) {return data})
                .then((data) => {
                    const { lat, lon } = data.data.instructorLocation
                    localStorage.setItem(course_id, `${lat}:${lon}`)
                    console.log('Set instructor geo location data')
                })
            }])
    } else (console.log('Not setting class location, local storage item exists'))
}

const sendRandomAnswer = (question) => {
    if ( question !== null ) {
        setTimeout(() => {
            const randChoice = MCQ_CHOICES[Math.floor(Math.random() * MCQ_CHOICES.length)]
            question.setAnswer(randChoice)
            document.getElementById(`multiple-choice-${randChoice}`).setAttribute("aria-pressed", true)
        }, SEND_ANSWER_DELAY)
    }
}

let sessionAvailability = {"activeSessionPresent": false,"attendanceActive": false,"pollActive": false,"quizActive": false,"courseHistoryNeedsRefresh": false,"locationRequired": true,"classSessionActive": true,"focused": false,"focusMode": null}

const inject = () => {
    angular.element(document.body).injector().invoke(["$routeParams", "$rootScope", "Session", "appBus", "events", "joinSessionService", (routeParams, rootScope, session, appBus, events, jSS) => {
        appBus.subscribe((e)=>sessionAvailability = e).to(events.courseScreen.sessionAvailabilityUpdated)
        rootScope.$watch(()=>session.currentPollingQuestion, ()=>{sendRandomAnswer(session.currentPollingQuestion)})
        rootScope.$watch(()=>sessionAvailability.activeSessionPresent, ()=>{if(sessionAvailability.activeSessionPresent) setTimeout(()=>jSS.joinSession(routeParams.id, sessionAvailability), JOIN_SESSION_DELAY)})
        rootScope.$watch(()=>session.activeSessionType, ()=>{if(session.activeSessionType === 0 && sessionAvailability.activeSessionPresent) sessionAvailability.activeSessionPresent = false})
    }])

    angular.element(document.body).injector().invoke(["ExpressRouterService", "Courses", function(i, Courses) {
        Courses.joinAttendanceSession = (e, t) => {
            console.log('Posting student geo location data')
    
            const [lat, lon] = localStorage.getItem(t) ? localStorage.getItem(t).split(":") : [e.geo.lat, e.geo.lon]
    
            if (!localStorage.getItem(t)) { console.log('Location data does not exist for class. Setting data ( will require you to join again ).'); setClassLocation();}
    
            e.geo.lat = lat
            e.geo.lon = lon
    
            return i.post("/api/courses/" + t + "/attendance/join", e).success(function() {return {}}).error(function(e) {return e})
        }
    }])

    angular.element(document.body).injector().invoke(["joinSessionService", (jSS) => {
        const joinSession = jSS.joinSession
        jSS.joinSession = (e,t,n) => setClassLocation().then(()=>{console.log("joining class"); joinSession(e,t,n);})
    }])
}

const waitForAngular = () => {
    const scope = angular.element(document.body).scope()
    scope ? inject() : setTimeout(waitForAngular, 100)
}

waitForAngular()